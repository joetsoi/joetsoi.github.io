<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ggez on Joe T</title>
    <link>https://the.chuntering.dev/tags/ggez/</link>
    <description>Recent content in ggez on Joe T</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Mon, 13 Jan 2020 01:00:43 +0000</lastBuildDate>
    
	<atom:link href="https://the.chuntering.dev/tags/ggez/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Pixel Games in Rust With ggez - Fixing Blurry Images</title>
      <link>https://the.chuntering.dev/posts/fixing-blurry-pixel-art-in-rust-ggez-games/</link>
      <pubDate>Mon, 13 Jan 2020 01:00:43 +0000</pubDate>
      
      <guid>https://the.chuntering.dev/posts/fixing-blurry-pixel-art-in-rust-ggez-games/</guid>
      <description>TL; DR - if you are making a pixel art game with rust + ggez and scaling the textures, then you probably want to set the default filtering to Nearest, with the line
graphics::set_default_filter(ctx,graphics::FilterMode::Nearest);The problem This basic ggez example that draws an image to the screen.
useggez;useggez::event;useggez::graphics;useggez::nalgebra;useggez::{Context,GameResult};struct MainState{image: graphics::Image,}implMainState{fn new(ctx: &amp;amp;mutContext)-&amp;gt; GameResult&amp;lt;MainState&amp;gt;{lets=MainState{image: graphics::Image::new(ctx,&amp;#34;/map.png&amp;#34;)?,};Ok(s)}}implevent::EventHandlerforMainState{fn update(&amp;amp;mutself,_ctx: &amp;amp;mutContext)-&amp;gt; GameResult{Ok(())}fn draw(&amp;amp;mutself,ctx: &amp;amp;mutContext)-&amp;gt; GameResult{graphics::draw(ctx,&amp;amp;self.image,graphics::DrawParam::new().scale(nalgebra::Vector2::new(3.0,3.0)),)?;graphics::present(ctx)?;Ok(())}}pubfn main()-&amp;gt; GameResult{letcb=ggez::ContextBuilder::new(&amp;#34;pixel art example&amp;#34;,&amp;#34;ggez&amp;#34;);let(ctx,event_loop)=&amp;amp;mutcb.build()?;letstate=&amp;amp;mutMainState::new(ctx)?;event::run(ctx,event_loop,state)}The result is not what you might expect if you&#39;re looking for crisp pixel art.</description>
    </item>
    
    <item>
      <title>OpenMoonstone V0.2 Released</title>
      <link>https://the.chuntering.dev/posts/openmoonstone-v0-2-released/</link>
      <pubDate>Wed, 16 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://the.chuntering.dev/posts/openmoonstone-v0-2-released/</guid>
      <description>OpenMoonstone v0.2 released OpenMoonstone is a open source reimplementation of Moonstone: A Hard Day&#39;s Knight following along the lines of projects like OpenTTD and OpenXcom. You can try it out https://github.com/joetsoi/OpenMoonstone
This release is a milestone as it contains the same number of features as the original demo that came out on the Amiga.
Why reimplement an old game? Fixing bugs   Original     OpenMoonstone v0.2   Enemies always face the player in Moonstone, in the original this meant that for the AI controlled knights, the distance the knight would move was out of sync with the animation causing a &amp;ldquo;jumpy&amp;rdquo; animation.</description>
    </item>
    
  </channel>
</rss>